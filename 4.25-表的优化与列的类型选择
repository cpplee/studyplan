#复习mysql优化

列选择原则:
1:字段类型优先级 整型 > date,time > enum,char>varchar > blob
列的特点分析:
整型: 定长,没有国家/地区之分,没有字符集的差异
time定长,运算快,节省空间. 考虑时区,写sql时不方便 where > ‘2005-10-12’;
enum: 能起来约束值的目的, 内部用整型来存储,但与char联查时,内部要经历串与值的转化
Char 定长, 考虑字符集和(排序)校对集
varchar, 不定长 要考虑字符集的转换与排序时的校对集,速度慢.
text/Blob 无法使用内存临时表

附: 关于date/time的选择,大师的明确意见
http://www.xaprb.com/blog/2014/01/30/timestamps-in-mysql/


MariaDB [lush_info]> create table t3(
    -> name char(1) not null default '',
    -> key(name)
    -> )engine=myisam charset=utf8;
Query OK, 0 rows affected (0.03 sec)

MariaDB [lush_info]> create table t4(
    -> name char(1),
    -> key(name)
    -> )engine=myisam charset=utf8;
Query OK, 0 rows affected (0.00 sec)

MariaDB [lush_info]> insert into t3 values('a'),('');
Query OK, 2 rows affected (0.08 sec)
Records: 2  Duplicates: 0  Warnings: 0

MariaDB [lush_info]> insert into t4 values('a'),(null);Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

MariaDB [lush_info]> select * from t3 where name='a';
+------+
| name |
+------+
| a    |
+------+
1 row in set (0.00 sec)



MariaDB [lush_info]> explain select * from t3 where name='a'\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t3
         type: ref
possible_keys: name
          key: name
      key_len: 3
          ref: const
         rows: 1
        Extra: Using where; Using index
1 row in set (0.00 sec)

MariaDB [lush_info]> explain select * from t4 where name='a'\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t4
         type: ref
possible_keys: name
          key: name
      key_len: 4
          ref: const
         rows: 1
        Extra: Using where; Using index
1 row in set (0.00 sec)

======================================================================
观察t3和t4的key_len不一样 ,用来区分null ,null占的索引空间更大(多一个字节,上万个数据就是上万个字节,查询也不方便),建表的时候不要用null,最好用not null


Enum列的说明
1: enum列在内部是用整型来储存的
2: enum列与enum列相关联速度最快
3: enum列比(var)char 的弱势---在碰到与char关联时,要转化. 要花时间.
4: 优势在于,当char非常长时,enum依然是整型固定长度.
当查询的数据量越大时,enum的优势越明显.
5: enum与char/varchar关联 ,因为要转化,速度要比enum->enum,char->char要慢,
但有时也这样用-----就是在数据量特别大时,可以节省IO.


==============================================================================================================================
1:索引类型
  1.1 B-tree索引
  注: 名叫btree索引,大的方面看,都用的平衡树,但具体的实现上, 各引擎稍有不同,
比如,严格的说,NDB引擎,使用的是T-tree
  Myisam,innodb中,默认用B-tree索引

但抽象一下---B-tree系统,可理解为”排好序的快速查找结构”.  

1.2 hash索引
     在memory表里,默认是hash索引, hash的理论查询时间复杂度为O(1)

疑问: 既然hash的查找如此高效,为什么不都用hash索引?
答: 
1:hash函数计算后的结果,是随机的,如果是在磁盘上放置数据,
比主键为id为例, 那么随着id的增长, id对应的行,在磁盘上随机放置.
2: 无法对范围查询进行优化.
3: 无法利用前缀索引. 比如 在btree中, field列的值“hellopworld”,并加索引
查询 xx=helloword,自然可以利用索引, xx=hello,也可以利用索引. (左前缀索引)
因为hash(‘helloword’),和hash(‘hello’),两者的关系仍为随机
4: 排序也无法优化.
5: 必须回行.就是说 通过索引拿到数据位置,必须回到表中取数据


